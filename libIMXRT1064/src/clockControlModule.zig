pub const ClockGatingState = enum(u2) {
    alwaysOff = 0,
    onWhileInRunMode = 1,
    onWhileInRunOrWaitMode = 3,
};

pub const GatingRegister0 = packed struct(u32) {
    aips_tz1: ClockGatingState,
    aips_tz2: ClockGatingState,
    mqs: ClockGatingState,
    _pad1: u2,
    sim_m_main_register_access: ClockGatingState,
    dcp: ClockGatingState,
    lpuart3: ClockGatingState,
    can1: ClockGatingState,
    can1_serial: ClockGatingState,
    can2: ClockGatingState,
    can2_serial: ClockGatingState,
    trace: ClockGatingState,
    gpt2_bus: ClockGatingState,
    gpt2_serial: ClockGatingState,
    lpuart2: ClockGatingState,
    gpio2: ClockGatingState,
};

pub const GatingRegister1 = packed struct(u32) {
    lpspi1: ClockGatingState,
    lpspi2: ClockGatingState,
    lpspi3: ClockGatingState,
    lpspi4: ClockGatingState,
    adc2: ClockGatingState,
    enet: ClockGatingState,
    pit: ClockGatingState,
    aoi2: ClockGatingState,
    adc1: ClockGatingState,
    semc_exsc: ClockGatingState,
    gpt1_bus: ClockGatingState,
    gpt1_serial: ClockGatingState,
    lpuart4: ClockGatingState,
    gpio1: ClockGatingState,
    csu: ClockGatingState,
    gpio5: ClockGatingState,
};
pub const GatingRegister2 = packed struct(u32) {
    ocram_exsc: ClockGatingState,
    csi: ClockGatingState,
    iomuxc_snvs: ClockGatingState,
    lpi2c1: ClockGatingState,
    lpi2c2: ClockGatingState,
    lpi2c3: ClockGatingState,
    ocotp_ctrl: ClockGatingState,
    xbar3: ClockGatingState,
    ipmux1: ClockGatingState,
    ipmux2: ClockGatingState,
    ipmux3: ClockGatingState,
    xbar1: ClockGatingState,
    xbar2: ClockGatingState,
    gpio3: ClockGatingState,
    lcd: ClockGatingState,
    pxp: ClockGatingState,
};
pub const GatingRegister3 = packed struct(u32) {
    flexio2: ClockGatingState,
    lpuart5: ClockGatingState,
    semc: ClockGatingState,
    lpuart6: ClockGatingState,
    aoi1: ClockGatingState,
    lcdif_pix: ClockGatingState,
    gpio4: ClockGatingState,
    ewm: ClockGatingState,
    wdog1: ClockGatingState,
    flexram: ClockGatingState,
    acmp1: ClockGatingState,
    acmp2: ClockGatingState,
    acmp3: ClockGatingState,
    acmp4: ClockGatingState,
    ocram: ClockGatingState,
    iomuxc_snvs_gpr: ClockGatingState,
};
pub const GatingRegister4 = packed struct(u32) {
    sim_m7_register_access: ClockGatingState,
    iomuxc: ClockGatingState,
    iomuxc_gpr: ClockGatingState,
    bee: ClockGatingState,
    sim_m7: ClockGatingState,
    tsc_dig: ClockGatingState,
    sim_m: ClockGatingState,
    sim_ems: ClockGatingState,
    pwm1: ClockGatingState,
    pwm2: ClockGatingState,
    pwm3: ClockGatingState,
    pwm4: ClockGatingState,
    enc1: ClockGatingState,
    enc2: ClockGatingState,
    enc3: ClockGatingState,
    enc4: ClockGatingState,
};
pub const GatingRegister5 = packed struct(u32) {
    rom: ClockGatingState,
    flexio1: ClockGatingState,
    wdog3: ClockGatingState,
    dma: ClockGatingState,
    kpp: ClockGatingState,
    wdog2: ClockGatingState,
    aipstz4: ClockGatingState,
    spdif: ClockGatingState,
    sim_main: ClockGatingState,
    sai1: ClockGatingState,
    sai2: ClockGatingState,
    sai3: ClockGatingState,
    lpuart1: ClockGatingState,
    lpuart7: ClockGatingState,
    snvs_hp: ClockGatingState,
    snvs_lp: ClockGatingState,
};
pub const GatingRegister6 = packed struct(u32) {
    usboh3: ClockGatingState,
    usdhc1: ClockGatingState,
    usdhc2: ClockGatingState,
    dcdc: ClockGatingState,
    ipmux4: ClockGatingState,
    flexspi: ClockGatingState,
    trng: ClockGatingState,
    lpuart8: ClockGatingState,
    timer4: ClockGatingState,
    aips_tz3: ClockGatingState,
    sim_axbs_p: ClockGatingState,
    anadig: ClockGatingState,
    lpi2c4_serial: ClockGatingState,
    timer1: ClockGatingState,
    timer2: ClockGatingState,
    timer3: ClockGatingState,
};
pub const GatingRegister7 = packed struct(u32) {
    enet2: ClockGatingState,
    flexspi2: ClockGatingState,
    axbs_l: ClockGatingState,
    can3: ClockGatingState,
    can3_serial: ClockGatingState,
    aips_lite: ClockGatingState,
    flexio3: ClockGatingState,
    _pad0: u18,
};

const CCM = extern struct {
    control: u32,
    _pad0: u32,
    status: u32,
    clockSwitcher: packed struct(u32) {
        pll3SwClkSrc: enum(u1) { pll3_main_clk = 0, pll3_bypass_clk = 1 },
        _pad0: u31,
    },
    armClockRoot: u32,
    busClockDivider: packed struct(u32) {
        _pad0: u6 = 0,
        semcClockSelect: enum(u1) { periph_clk = 0, semc_alternate = 1 },
        semcAltClockSelect: enum(u1) { pll2pfd2 = 0, pll3pfd1 = 1 },
        ipgPodfDenominatorMinusOne: u2,
        ahbPodfDenominatorMinusOne: u3,
        _pad1: u3 = 0,
        semcPodfDenominatorMinusOne: u3,
        _pad2: u6 = 0,
        peripheralClockSelect: enum(u1) { pre_periph_clk_sel = 0, periph_clk2_clk_divided = 1 },
        _pad3: u1 = 0,
        peripheralClk2PodfDenominatorMinusOne: u3,
        _pad4: u2 = 0,
    },
    busClockMultiplexer: packed struct(u32) {
        _pad0: u4,
        lpspiSelect: enum(u2) { pll3_pfd2 = 0, pll3_pfd0 = 1, pll3_pfd1 = 2, pll2 = 3 },
        _pad1: u2,
        flexspi2Select: enum(u2) { pll2_pfd2 = 0, pll3_pfd0 = 1, pll3_pfd1 = 2, pll2 = 3 },
        _pad2: u2,
        periphClk2Select: enum(u2) { pll3_sw_clk = 0, osc_clk = 1, pll2_bypass_clk = 3 },
        traceSelect: enum(u2) { pll2 = 0, pll2_pfd2 = 1, pll2_pfd0 = 2, pll2_pfd1 = 3 },
        _pad3: u2,
        prePeriphSelect: enum(u2) { pll2 = 0, pll2_pfd2 = 1, pll2_pfd0 = 2, pll1 = 3 },
        _pad4: u3,
        lcdifPostDividerMinusOne: u3,
        lpspiDivierMinusOne: u3,
        flexspi2DividerMinusOne: u3,
    },
    serialClockMultiplexer1: u32,
    serialClockMultiplexer2: u32,
    serialClockDivider1: packed struct(u32) {
        dividerForUartClockPodfMinusOne: u6,
        uartClockSelector: enum(u1) { pll3Div6 = 0, deriveFromOscClk = 1 },
        _pad0: u4,
        dividerForUsdhc1ClockPodfMinusOne: u3,
        _pad1: u2,
        dividerForUsdhc2ClockMinusOne: u3,
        _pad2: u6,
        dividerForTraceClockMinuxOne: u2,
        _pad3: u1,
        _pad4: u4 = 0,
    },
    clockDivider1: u32,
    clockDivider2: u32,
    d1ClockDivider: u32,
    _pad1: u32,
    serialClockDivider2: u32,
    serialClockDivider3: u32,
    _pad2: u32,
    _pad3: u32,
    dividerHandshakeInProcess: u32,
    _pad4: u32,
    _pad5: u32,
    lowPowerControl: packed struct(u32) {
        mode: enum(u2) {
            runMode = 0,
            waitMode = 1,
            stopMode = 2,
        },
        _pad0: u3,
        armClockDisabledInWaitMode: bool,
        powerDownOnChipOscillatorInStopMode: bool,
        disableHighFrequencyOscillator: bool,
        standbyVoltageInStopMode: bool,
        standbyCounter: enum(u2) {
            pmicDelayScaler = 0,
            pmicDelayScalerMul3 = 1,
            pmicDelayScalerMul7 = 2,
            pmicDelayScalerMul15 = 3,
        },
        powerDownOnChipOscillator: bool,
        _pad1: u7,
        bypassLowPowerModeHandshake1: bool,
        _pad2: u1,
        bypassLowPowerModeHandshake2: bool,
        maskWFICore0: bool,
        _pad3: u3,
        maskSCUIdleOnLowPowerMode: bool,
        maskL2CCIdleOnLowPowerMode: bool,
        _pad4: u4,
    },
    interruptStatus: u32,
    interruptMask: u32,
    clockOutputSource: u32,
    gpr: u32,
    // I wanted to be clever with all of these and stick them all in a big packed u256.
    // Maybe it did work? but it was so hard to verify that things were where I expected them to be that I
    //  gave up. Oh well.
    gating0: GatingRegister0,
    gating1: GatingRegister1,
    gating2: GatingRegister2,
    gating3: GatingRegister3,
    gating4: GatingRegister4,
    gating5: GatingRegister5,
    gating6: GatingRegister6,
    gating7: GatingRegister7,
    enableOverride: u32,
};

fn CCMAnalogRegisterSet(t: type) type {
    return extern struct {
        data: t,
        set: t,
        clear: t,
        toggle: t,
    };
}

const CCM_ANALOG_REGISTER_SET_UNKNOWN = CCMAnalogRegisterSet(u32);

const CCMAnalog = extern struct {
    armPllControl: CCM_ANALOG_REGISTER_SET_UNKNOWN,
    usb1_480mhzPll: CCMAnalogRegisterSet(packed struct(u32) {
        _pad0: u1,
        pllLoopDividerSelection: enum(u1) { refTimes20 = 0, refTimes22 = 1 },
        _pad1: u4,
        enable9PhaseUSBPHYPll: bool,
        _pad2: u5,
        powerOn: bool,
        enablePll: bool,
        bypassSource: enum(u2) { refClk24M = 0, clk1 = 1 },
        bypass: bool,
        _pad3: u14,
        lock: bool,

        pub fn get(self: *const volatile @This()) u32 {
            if (!self.enablePll) return 0;
            const refClock = switch (self.bypassSource) {
                .refClk24M => xtalOscillator.getClockHz(),
                .clk1 => 0, // I don't know what this is
            };
            if (self.bypass) {
                return refClock;
            }
            return refClock * ((if (self.pllLoopDividerSelection == .refTimes20) @as(u32, 20) else @as(u32, 22)));
        }
    }),
    usb2_480mhzPll: CCM_ANALOG_REGISTER_SET_UNKNOWN,
    systemPll: CCM_ANALOG_REGISTER_SET_UNKNOWN,
    system528mhzPllSpreadSpectrum: u32,
    _pad0: u32,
    _pad1: u32,
    _pad2: u32,
    system528mhzPllNumerator: u32,
    _pad3: u32,
    _pad4: u32,
    _pad5: u32,
    system528mhzPllDenominator: u32,
    _pad6: u32,
    _pad7: u32,
    _pad8: u32,
    audioPll: CCM_ANALOG_REGISTER_SET_UNKNOWN,
    audioPllNumerator: u32,
    _pad9: u32,
    _pad10: u32,
    _pad11: u32,
    audioPllDenominator: u32,
    _pad12: u32,
    _pad13: u32,
    _pad14: u32,
    videoPll: CCM_ANALOG_REGISTER_SET_UNKNOWN,
    videoPllNumerator: u32,
    _pad15: u32,
    _pad16: u32,
    _pad17: u32,
    videoPllDenominator: u32,
    _pad18: u32,
    _pad19: u32,
    _pad20: u32,
    _pad21: u32,
    _pad22: u32,
    _pad23: u32,
    _pad24: u32,
    enetPll: CCM_ANALOG_REGISTER_SET_UNKNOWN,
    pll3_480mhzPhaseDividerControl: CCMAnalogRegisterSet(packed struct(u32) {
        pfd0Frac: u6 = 0,
        pfd0Stable: bool = false,
        pfd0ClockGate: bool = false,
        pfd1Frac: u6 = 0,
        pfd1Stable: bool = false,
        pfd1ClockGate: bool = false,
        pfd2Frac: u6 = 0,
        pfd2Stable: bool = false,
        pfd2ClockGate: bool = false,
        pfd3Frac: u6 = 0,
        pfd3Stable: bool = false,
        pfd3ClockGate: bool = false,
    }),
    pll2_528mhzPhaseDividerControl: CCMAnalogRegisterSet(packed struct(u32) {
        pfd0Frac: u6 = 0,
        pfd0Stable: bool = false,
        pfd0ClockGate: bool = false,
        pfd1Frac: u6 = 0,
        pfd1Stable: bool = false,
        pfd1ClockGate: bool = false,
        pfd2Frac: u6 = 0,
        pfd2Stable: bool = false,
        pfd2ClockGate: bool = false,
        pfd3Frac: u6 = 0,
        pfd3Stable: bool = false,
        pfd3ClockGate: bool = false,
    }),
    _pad25: [16]u32,
    misc0: CCM_ANALOG_REGISTER_SET_UNKNOWN,
    misc1: CCM_ANALOG_REGISTER_SET_UNKNOWN,
    misc2: CCM_ANALOG_REGISTER_SET_UNKNOWN,
};

const XTALOscillator = extern struct {
    misc: CCMAnalogRegisterSet(u32),
    lowPowerControl: CCMAnalogRegisterSet(packed struct(u32) {
        rcOscEnabled: bool,
        _pad0: u3,
        clockSrc: enum(u1) { xtal = 0, rc = 1 },
        lowPowerBandgap: bool,
        lowPowerBandgapTestBit: bool,
        lowPowerReftopIbiasDisable: bool,
        l1PowerGate: bool,
        l2PowerGate: bool,
        cpuPowerGate: bool,
        displayLogicPowerGate: bool,
        _pad1: u1,
        rcoscGcOverride: bool,
        xtaloscPowerupDelay: enum(u2) { @"250us" = 0, @"500us" = 1, @"1000us" = 2, @"2000us" = 3 },
        xtaloscStatus: enum(u1) { unstable = 0, stable = 1 },
        displayPowerGate: bool,
        gpuPowerGate: bool,
        _pad2: u13,
    }),
    config0: CCMAnalogRegisterSet(u32),
    config1: CCMAnalogRegisterSet(u32),
    config2: CCMAnalogRegisterSet(u32),
    pub fn getClockHz(self: *const volatile @This()) u32 {
        return if (self.lowPowerControl.data.clockSrc == .xtal) 24000000 else 0; // Dunno how to handle external clock
    }
};

pub const xtalOscillator: *volatile XTALOscillator = @ptrFromInt(0x400D8150);
pub const ccm: *volatile CCM = @ptrFromInt(0x400FC000);
pub const ccmAnalog: *volatile CCMAnalog = @ptrFromInt(0x400D8000);
